책 그대로 배끼면서 연습!

우분투 환경에서
C언어로 배우는 리눅스 프로그래밍
=====
> 이이오 준 지음, 김성재 옮김, 한빛미디어 출판

-----------------------------------------------------

> 프로그램 소스를 분할하는 이유

- 프로그램의 구조화

프로그램 전체를 각각의 파일로 나누면 프로그램 전체의 구성을 파악하기 쉬워짐.

- 빌드 시간 단축

일반적으로 컴파일 처리에는 어느 정도 시간이 걸림. 하지만 앞에서 본 분할 컴파일의 예처럼 소스 코드를 나눠두면 일부분을 수정했을 때 그 파일만 다시 컴파일하면 됨.
새로 컴파일된 오브젝트 파일을 링크하면 전체를 갱신할 수 있기 때문임.

- 여러 개발자에 의한 개발

동시에 여러 개발자가 개발하기 쉬운 장점이 있음.

- 유지보수 향상 대책

프로그램을 나누고 구조화한 결과 플랫폼에 의존하는 부분을 잘라내 격리하는 일이 자주 일어남.  분할하면 유지보수가 쉬워짐. 다른 플랫폼으로 이식할 때도 분할한 부분을 중심으로 검토하면 됨.

--------

> make의 이용

- 배치파일의 문제점

유감스럽게도 list0321.sh는 분할 컴파일의 장점을 희생시키는 중대한 문제점이 있음. list0321.sh 로 일괄처리하면 모든 소스 코드를 재컴파일해 버림. 규모가 크고 복잡한 프로그램이면 개발 효율이 저하됨.

- make

*분할 컴파일의 장점도 살리면서 어떻게든 빌드를 자동화 할 수 있게 하는 도구가 바로 make!*
make에는 각 파일 사이의 의존성을 파악하고 파일의 타임스탬프를 비교해 다시 생성할 필요가 있는지 판단하는 기능이 있음.

- makefile

'소스 데이터로부터 결과물이 (어떤 수단으로) 만들어진다'는 규칙을 파일에 작성해 두면 make는 파일을 해석해 순차적으로 처리함. 이 규칙을 작성한 파일을 'makefile'이라고
하고 기본 메이크파일의 이름은 Makefile. make -f filename처럼 -f 옵션을 주고 이름을 지정하면 다른 이름으로 메이크파일을 지정할 수 있음.

메이크파일에는 결과물과 소스 데이터와의 관계를 '결과물: 소스 데이터'처럼 콜론(:)으로 연결해 작성. 하나의 결과물에 여러개의 소스 데이터를 연결할 수 있다. 그리고 다음
줄에는 변환 수단을 작성. 구체적으로는 터미널에 입력해야 하는 명령 또는 배치파일에 기재한 명령을 작성. 이때 명령은 반드시 '탭tab'으로 들여쓰기 해서 작성해야 함.

- make의 동작

touch list0311A.c로 소스 코드를 수정한 것처럼 한 후, 다시 make 명령을 실행하면 list0311B.c는 수정하지 않았으므로 재컴파일 하지 않음.
make를 이용하면 분할 컴파일의 장점을 살릴 수 있음.

*touch는파일의 timestamp를 현재 시간으로 새로 고치는 명령. 이 조작으로 어떤 수정을 했다는 것을 모의적으로 처리. 만약 파일이 없으면 빈 파일을 생성.*

> 다양한 make의 기능

make의 개념은 아주 중요함. 특히 make에서 사용되는 매크로나 내부 매크로는 범용적으로 이용되므로 익숙해 져야함.

- 매크로의 자동 변수

매크로의 정의와 자동 변수(automatic variables). 간단히 말해 매크로는 '치환하는 기능'. 또한, 자동 변수는 내부적으로 정의되어 자동으로 치환되는 더 범용적인 매크로라고
생각할 수 있음.

$^는 의존 관계가 있는 모든 파일을 나타냄. 여기서는 $(OBJS)가 그에 해당. 한편 $@는 타깃 파일을 나타내며 마찬가지로 $(TARGET)에 해당. make 내부에 미리 정의된 매크로
목록을 보려면 터미널에서 make -p 명령을 실행하면 되지만, 이때 내부 매크로는 표시하지 않음. 

- 그 밖의 기능

암묵적인 규칙의 추가, 더미 타깃, 명령 삽입 등 그 밖에 자주 이용되는 기능은 더미 타깃(Dummy target). 보통 타깃과 달리 더미 타깃은 의존하는 파일이 없고 타깃 파일로 생성되지 않음. make를 실행할 때 타깃을 지정할 수 있는 점을 이용해 따로 처리하고자 하는 명령을 더미 타깃으로 작성하는 방법을 자주 이용함.

> make의 다양한 활용법

make 명령은 프로그래밍 이외의 분야에도 활용가능. 프로젝트를 구성하는 파일 사이에 어떤 의존성이 있고 원본 데이터에 변경이 가해졌을 때, 필요한 최소한의 수정만 하면 되는 경우 사용. 그 밖에 수치 데이터를 스크립트로 처리해 그래프 만들기, 텍스트 데이터를 데이터 마이닝 도구로 처리해 문서로 정리하기 등..

-----

> 라이브러리

'바퀴의 재발명은 피하라' 그 자산이란 소프트웨어 라이브러리.

- 다양한 라이브러리와 API
 
과학기술계산, 데이터베이스, 유저 인터페이스, 다양한 기기로의 접근 등에 사용되는 각양각색의 라이브러리 존재.

이런 라이브러리의 기능은 API(Application Program Interface)를 통해 사용가능. 

- 라이브러리와의 링크

라이브러리를 이용한 프로그램은 어떤 오브젝트 코드로 컴파일되는 것일까? 라이브러리에 의존하는 프로그램은 시스템에 필요한 라이브러리가 설치되지 않으면 동작하지 않음.
실제로 실행될 때는 라이브러리가 제공하는 코드와 결합(링크)해야 비로소 올바른 프로그램 코드가 되어 프로그래머의 의도대로 동작.

오브젝트 코드와 라이브러리를 결합하는 방법에 따라 정적(static) 라이브러리와 공유(shared) 라이브러리로 나뉨. 다시 공유 라이브러리는 일반적인 동적링크(dynamic link)
와 실행 시 필요에 따라 라이브러리 코드를 메모리에 로드하는 동적 로드(dynamic load)로 나뉨.

- 정적 라이브러리와 공유 라이브러리

정적 라이브러리를 사용할 때는 프로그램 빌드 시에 라이브러리가 제공하는 코드를 실행 파일에 넣음. 이 방식의 장점은 시스템 환경이 변해도 어플리케이션에 아무런 영향이
없고, 완성된 어플리케이션을 안정적으로 사용할 수 있음. 반면에 사용하는 모든 오브젝트 코드를 실행 파일에 내장하므로 메모리에 로드되는 어플리케이션 코드 크기가 커짐. 

공유 라이브러리는 이런 단점 해결. '공유'란 어떤 라이브러리가 제공하는 기능을 다른 어플리케이션에서 사용하고 싶을 때 라이브러리 코드를 메모리에 하나만 두고 각 어플리케이션에서 공유하는 것을 가리킴.

라이브러리 코드와 어플리케이션의 코드가 실행될 때 메모리에 로드되는 시점에 비로소 결합. 즉, 라이브러리를 이용하는 어플리케이션에는 '호출할 라이브러리 함수'의 정보만 들어있음.

- 동적 로드에 의한 어플리케이션의 확장

더욱 자유도가 높은 라이브러리 활용법은 동적 로드. 동적 링크 방식에서는 어플리케이션을 실행하면 실행 파일과 관련된 라이브러리 코드를 모두 메모리에 읽어들여 호출 관계를 조정한 다음 어플리케이션이 실행됨. 

동적 로드에서는 프로그램 내부에서 라이브러리를 로드함. 어느 라이브러리의 어느 함수를 이용할지는 프로그램의 동작 상황에 따라 변할 수 있음. 대다수 어플리케이션에서 자주 이용되는 플러그인에 의한 기능 확장은 동적 로드를 이용해 구현.

- 라이브러리의 의존성

라이브러리의 의존성을 확인하는 명령 ldd가 있다. ldd를 실행하면 그 어플리케이션이 이용하는 라이브러리를 보여줌.

> 헤더 파일의 역할

- 프리프로세서의 동작

컴파일러 드라이버인 gcc는 몇몇 도구를 호출해 C 프로그램 빌드를 진행함. 옵션 -E를 사용하면

```
컴파일과 링크와 실행 파일 만들기
1. 프리프로세서에 의한 파일 포함과 매크로 처리
2. 어셈블리 코드로 컴파일하고 어셈블 과정을 거쳐 오브젝트 파일로 변환
3. 오브젝트 파일 결합과 라이브러리 링크
```

위 과정중 1단계에서 중단하고 결과를 표준 출력으로 보낸 후 처리를 종료.
이 단계에서 #으로 시작되는 줄은 주석으로 처리.

포함할 파일을 어디에서 찾아오느냐의 차이점.
"..." (인용부호)로 지정하면 소스파일이 있는 디렉터리를 먼저 찾고, <...>로 지정하면 시스템이 준비한 디렉터리를 먼저 찾음.

> 사전으로서의 헤더 파일

- 함수 프로토타입 선언

list0333A.c	list0333B.c	list0333C.c 를 진행하면서

함수가 어떤 인수를 받고 어떤 형의 반환 값을 돌려줄지 개별적으로 작성 어려움. 또한 외부 파일에서 정의되는 구조체와 새롭게 정의되는 형을 이용할 때도 있음.
따라서 이런 정의를 모아둔 파일을 참조할 수밖에 없는 상태가 될 것임. 이것이 바로 헤더 파일.

헤더 파일의 함수 프로토타입 선언에 맞게 프로그래밍해야 하며 적절한 라이브러리의 링크를 지정해야 함.

- 라이브러리가 제공하는 함수 목록

헤더 파일을 보기만 해도 라이브러리의 사용법을 제대로 알 수 있음. 물론 각각의 API를 어떻게 사용하면 좋을지는 라이브러리에 첨부된 문서를 읽어야 함.

- G_BEGIN_DECLS란?

gstring.h 에서 사용되는 G_BEGIN_DECLS는 무엇을 정의?? /usr/include/glib-2.0/glib/gmacros.h에 다음처럼 정의.

```
/* Guard C code in headers, while including them from C++ */
#ifdef	__cplusplus
# define G_BEGIN_DECLS	extern "C" {
# define G_END_DECLS	}
#else
# define G_BEGIN_DECLS
# define G_END_DECLS
#endif
```

이 정의는 C 프로그래밍에서는 의미가 없음. 즉 __cplusplus가 정의되어 있지 않으면 공백으로 변환되어 버림.

이 코드는 라이브러리화했을 때 의미가 있음. C++ 에서 이용할 때는 이 매크로에 의미가 생김.
C++에서 C언어 코드를 이용할 때는 extern "C" {...}로 에워싸 C언어 함수임을 명시해야 함.
하지만 C언어에서는 불필요. 코드를 이용하는 언어에 따라 똑똑하게 전환하는 구조가 G_BEGIN_DECLS ... G_END_DECLS 임.

- 구조체의 확인

헤더 파일에 작성되는 정의는 함수의 프로토타입 뿐만 아니라 라이브러리에서 활용되는 구조체의 정의도 작성됨.

```
$ cat /usr/include/libio.h | less
```

로 확인해 보면 파일조작에 필요한 파일 디스크립터 구조체의 실체는 이렇게 정의되어 있다는 것을 알 수 있음. C프로그래밍 입문서에는 파일 디스크립터의
포인터 형태로 자주 보이는데, 헤더 파일을 조사하면 그 실체를 정확히 확인할 수 있음.

-----

###프로그램의 이식성

라이브러리를 활용해서 프로그래밍 할 때 주의할 점! '이식성'문제.

이식성은 시스템 환경이 바뀌어도 소프트웨어를 빌드할 수 있고 적절한 동작을 보증하는 것 혹은 그렇게 하기 위한 배려를 말함. 
다른 환경으로의 이식, OS를 넘어선 소프트웨어의 동작을 보증한다는 의미가 있으며 포터빌리티(Portability)라고도 함.

개발한 프로그램을 가능한 많은 사용자가 사용하게 하려면 프로그램의 이식성을 확보하고 가능한 한 많은 플랫폼에서 동작할 수 있어야 함.

> 플랫폼과 환경설정에 의한 차이

- OS에 의한 차이

플랫폼이 달라지면 시스템의 구조가 달라지는 것은 피할 수 없음. 마찬가지로 하드웨어가 달라지면 시스템의 동작도 달라짐. 

- 환경설정에 의한 차이

이식성을 신경쓰지 않은 채 배포되는 어플리케이션에는 의존하는 미들웨어와 라이브러리도 특정한 버전이 지정되어 있어, 새로운 버전에서 문제가 생기거나 혹은 반대로 최신 버전 라이브러리를 사용해야만 동작하는 등 환경구축 자체가 어려울 때도 있음.

> 차이를 극복하는 방법

- 소스코드에서 대처할 문제

	1. CPU 아키텍처 차이 : Big endian인지 little endian인지, 64bit인지 32bit인지, 그 이하 bit인지 등 비트를 직접 조작하는 코드를 작성할 때에는 주의!
	2. 라이브러리의 존재 : 해초에 활용할 라이브러리가 준비됬는지, 라이브러리의 버전은 적절하고 호출하는 함수의 시그니처가 맞는지, 구조체의 멤버 구성이 바뀌지 않았는지 등에 주의!

